Alright ‚Äî **full deep dive into closures**.
I‚Äôll take you from **zero ‚Üí JS engine level ‚Üí real-world patterns ‚Üí interview traps ‚Üí performance**.

---

# 1Ô∏è‚É£ What is a Closure? (Core Definition)

A **closure** is:

> A function that remembers variables from its **lexical scope** even after that outer function has finished executing.

In simple words:

üëâ A function + the variables it captured = **closure**

---

## Basic Example

```js
function outer() {
  let count = 0;

  function inner() {
    count++;
    console.log(count);
  }

  return inner;
}

const fn = outer();
fn(); // 1
fn(); // 2
fn(); // 3
```

### What‚Äôs happening?

* `outer()` runs ‚Üí creates `count`
* `outer()` returns `inner`
* `inner` still has access to `count`
* Even though `outer()` is **done**

That memory retention = **closure**

---

# 2Ô∏è‚É£ Why Closures Exist (Lexical Scope)

JS uses **lexical scoping** ‚Üí scope is determined by **where code is written**, not where it‚Äôs called.

```js
function outer() {
  let a = 10;

  function inner() {
    console.log(a);
  }

  return inner;
}

const fn = outer();
fn(); // 10
```

`inner` looks for `a` in:

1. Its own scope ‚ùå
2. Outer scope ‚úÖ
3. Global scope (if not found)

This lookup chain = **scope chain**

Closure = inner function + reference to outer scope

---

# 3Ô∏è‚É£ Closures in Memory (JS Engine View)

When a function is created, it gets a hidden property:

üëâ `[[Environment]]` ‚Üí reference to its lexical environment

So internally:

```
inner.[[Environment]] ‚Üí { count: 0 }
```

That‚Äôs why `count` is not garbage collected.

---

# 4Ô∏è‚É£ Each Function Gets Its Own Closure

```js
function createCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const c1 = createCounter();
const c2 = createCounter();

console.log(c1()); // 1
console.log(c1()); // 2
console.log(c2()); // 1 (separate memory)
```

Each call ‚Üí **new lexical environment**

---

# 5Ô∏è‚É£ Real Use Cases of Closures

## ‚úÖ Data Privacy (Encapsulation)

```js
function bankAccount(initialBalance) {
  let balance = initialBalance;

  return {
    deposit(amount) {
      balance += amount;
    },
    getBalance() {
      return balance;
    }
  };
}

const acc = bankAccount(1000);
acc.deposit(500);
console.log(acc.getBalance()); // 1500
```

`balance` is **private**

---

## ‚úÖ Function Factories

```js
function multiplyBy(x) {
  return function (y) {
    return x * y;
  };
}

const double = multiplyBy(2);
console.log(double(5)); // 10
```

---

## ‚úÖ Memoization

```js
function memoizedAdd() {
  const cache = {};

  return function (n) {
    if (cache[n]) return cache[n];
    cache[n] = n + n;
    return cache[n];
  };
}

const add = memoizedAdd();
add(5); // calculated
add(5); // from cache
```

Closures store the cache.

---

## ‚úÖ setTimeout / Async

```js
function greet(name) {
  setTimeout(function () {
    console.log("Hello " + name);
  }, 1000);
}

greet("Mrinal");
```

Even after `greet` finishes, `name` is remembered.

---

# 6Ô∏è‚É£ Closures + Loops (Classic Interview Trap)

## ‚ùå Using `var`

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

Output:

```
3
3
3
```

Because:

* `var` is function-scoped
* One shared `i`

---

## ‚úÖ Fix with `let`

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

Output:

```
0
1
2
```

Each iteration gets its own closure.

---

## ‚úÖ Fix with IIFE (old school)

```js
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => console.log(j), 1000);
  })(i);
}
```

---

# 7Ô∏è‚É£ Closures and Garbage Collection

Closures **keep variables alive**.

‚ö†Ô∏è Memory leak risk:

```js
function heavy() {
  let bigData = new Array(1000000).fill("data");

  return function () {
    console.log("using bigData");
  };
}

const fn = heavy();
```

`bigData` stays in memory as long as `fn` exists.

---

# 8Ô∏è‚É£ Closures vs Objects for Privacy

### Closure

```js
function Counter() {
  let count = 0;

  this.inc = () => count++;
  this.get = () => count;
}
```

### Class Private Field

```js
class Counter {
  #count = 0;

  inc() { this.#count++; }
  get() { return this.#count; }
}
```

Closures were the **original private variables** before `#`.

---

# 9Ô∏è‚É£ Closures in Functional Programming

### Currying

```js
function sum(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}

sum(1)(2)(3); // 6
```

Each layer captures previous values.

---

# üîü Module Pattern (Pre-ES6)

```js
const module = (function () {
  let privateVar = "secret";

  return {
    get() {
      return privateVar;
    }
  };
})();
```

Used before ES modules.

---

# 1Ô∏è‚É£1Ô∏è‚É£ Common Interview Questions

## Q1: What is a closure?

Function + lexical environment.

---

## Q2: When is closure created?

At **function creation time**, not execution time.

---

## Q3: Can closures access updated values?

Yes ‚Äî they capture **reference**, not copy.

```js
let x = 10;

function foo() {
  console.log(x);
}

x = 20;
foo(); // 20
```

---

## Q4: Closures vs Scope

Closure = scope + function + memory retention

---

# 1Ô∏è‚É£2Ô∏è‚É£ Advanced: Closures with Event Listeners

```js
function attach(index) {
  document
    .getElementById("btn")
    .addEventListener("click", function () {
      console.log(index);
    });
}
```

Each handler remembers its own `index`.

---

# 1Ô∏è‚É£3Ô∏è‚É£ Performance Considerations

Closures are:

‚úÖ Powerful
‚ö†Ô∏è Can cause memory retention
‚ö†Ô∏è Don‚Äôt overuse in hot loops

Bad:

```js
for (...) {
  element.addEventListener("click", () => heavyObject);
}
```

Better ‚Üí reuse function if closure not needed.

---

# 1Ô∏è‚É£4Ô∏è‚É£ Mental Model (Best Way to Remember)

When you see:

üëâ function inside function
üëâ returned function
üëâ async callback
üëâ event handler

Ask:

> ‚ÄúWhich variables from outer scope are being remembered?‚Äù

That‚Äôs the closure.

---

# 1Ô∏è‚É£5Ô∏è‚É£ Closure Visualization

```
outer execution finished ‚ùå
but
inner.[[Environment]] ‚Üí outer variables ‚úÖ
```

---

# 1Ô∏è‚É£6Ô∏è‚É£ Real Production Patterns

Closures are used in:

* React hooks (useState keeps closure over state setter)
* Redux middleware
* Debounce / Throttle
* Once functions
* Factory functions
* Private variables

---

# 1Ô∏è‚É£7Ô∏è‚É£ Debounce using Closure

```js
function debounce(fn, delay) {
  let timer;

  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

`timer` is stored via closure.

---

# 1Ô∏è‚É£8Ô∏è‚É£ Once Function

```js
function once(fn) {
  let called = false;

  return function (...args) {
    if (!called) {
      called = true;
      return fn.apply(this, args);
    }
  };
}
```

---

# üß† Final Interview-Level Definition

> A closure is formed when a function is created, allowing it to retain access to its lexical environment even after the outer function has completed execution.

---

# üöÄ If You‚Äôre Teaching This in Class

Best teaching flow:

1. Lexical scope
2. Returning inner function
3. Counter example
4. Loop trap (`var` vs `let`)
5. Real-world ‚Üí debounce
6. Memory discussion
7. Interview questions

---

# üß™ Want Practice?

I can give you:

* 10 closure coding problems (easy ‚Üí hard)
* Output-based interview questions
* React-specific closure gotchas (stale closures in hooks)

Which do you want next?
